from os import path, mkdir
from sys import argv
from dotenv import load_dotenv
import ast
import debugger as debug
import openai

load_dotenv()

EXPECTED_USAGE = """
Usage: guardrail <file> <function> [options]

Generate unit tests for a specific Python function.

Arguments:
  file            Path to the Python file containing the function (e.g., foo.py)
  function        The name of the function to generate tests for

Options:
  -o, --output <path>   Specify output file name (default: test_<file>.py)
  -d, --dir <path>      Specify output directory (default: test)
  -f, --framework <name>  Choose a testing framework (unittest, pytest) (default: pytest)
  -h, --help           Show this help message and exit

Examples:
  guardrail foo.py bar
  guardrail foo.py bar --framework unittest
  guardrail foo.py bar -o tests/test_bar.py -f pytest
"""

OPENAI_MODEL = "gpt-4o-mini"
TESTGEN_INSTRUCTIONS = """
Given the source code for a function, generate a full, working test script for that
function using the framework {framework}. Generate only the source code, ready to run. Do
not include anything else, not even triple tickmarks for markdown. The user will be responsible for
importing their function, so do not include an import statement for it.

The generated output must follow the following format:

# ============================ IMPORTS ============================
<import the test framework>
# TODO: import function to test

# ============================ TEST CASES ============================
# Unit tests for function: <function_name>
# File tested: <file_name>

<code for test cases goes here>
"""

ACCEPTED_FILE_EXTENSIONS = ["py"]
ACCEPTED_FRAMEWORKS = ["pytest", "unittest"]

DEFAULT_OUTPUT_DIR = "test"
DEFAULT_OUTPUT_FILE_PREFIX = "test_"
DEFAULT_FRAMEWORK = "pytest"

def main():
    # Parse command line arguments
    argc = len(argv)

    if argc < 3 or (argc == 2 and (argv[1] == "-h" or argv[1] == "--help")):
        print(EXPECTED_USAGE)
        return
    
    # Handle file name
    file_name = argv[1]

    # Verify file extension
    file_extension = file_name.split(".")[-1]

    if not file_extension in ACCEPTED_FILE_EXTENSIONS:
        print("File must have one of the following file extensions:", ", ".join(["." + e for e in ACCEPTED_FILE_EXTENSIONS]))
        return
    
    # Ensure file exists
    if not path.isfile(file_name):
        print("File does not exist:", file_name)
        return

    # Handle function name
    function_name = argv[2]

    # Handle options
    output_dir = DEFAULT_OUTPUT_DIR
    output_file = DEFAULT_OUTPUT_FILE_PREFIX + function_name + ".py"
    framework = DEFAULT_FRAMEWORK

    index = 3

    while index < argc:
        arg = argv[index]

        if arg == "-o" or arg == "--output":
            if index == argc - 1:
                print(EXPECTED_USAGE)
                return
            
            output_file = argv[index + 1]
            index += 2

        elif arg == "-d" or arg == "--dir":
            if index == argc - 1:
                print(EXPECTED_USAGE)
                return
            
            output_dir = argv[index + 1]
            index += 2

        elif arg == "-f" or arg == "--framework":
            if index == argc - 1:
                print(EXPECTED_USAGE)
                return
            
            framework = argv[index + 1].lower()

            if not framework in ACCEPTED_FRAMEWORKS:
                print("Framework must be one of the following:", ", ".join(ACCEPTED_FRAMEWORKS))
                return

            index += 2

        else:
            print("Unknown option:", argv[index])
            return

    debug.check_value("file_name", file_name)
    debug.check_value("function_name", function_name)
    debug.check_value("output_file", output_file)
    debug.check_value("output_dir", output_dir)
    debug.check_value("framework", framework)

    # Get function source code
    function_src = get_function_src(file_name, function_name)
    
    # Generate test script (function: generate_tests)
    test_src = generate_test_src(function_src, framework)

    # Write returned source code to file
    if not path.isdir(output_dir):
        mkdir(output_dir)

    with open(output_dir + "/" + output_file, "w") as output:
        output.write("\"\"\"\n")
        output.write("===================================================================\n")
        output.write("Guardrail Generated Test Suite\n")
        output.write("===================================================================\n")
        output.write("Generated by Guardrail - An AI-powered Python unit test generator\n")
        output.write("===================================================================\n")
        output.write("\"\"\"\n\n")

        output.write(test_src)

def generate_test_src(function_src, framework):
    openai_result = openai.responses.create(
        model=OPENAI_MODEL,
        instructions=TESTGEN_INSTRUCTIONS.format(framework=framework),
        input=function_src
    )

    if openai_result.output and openai_result.output[0].content:
        print()
        debug.check_value("LLM Call Result", openai_result)
        print()
        debug.check_value("output", openai_result.output)
        print()
        debug.check_value("first object in list", openai_result.output[0])
        print()
        debug.check_value("content of first result", openai_result.output[0].content)
        print()
        debug.check_value("Final text to be extracted", openai_result.output[0].content[0].text)
        print()

        return openai_result.output[0].content[0].text
    else:
        raise ValueError("Unexpected response structure or empty content")

def get_function_src(file_name, function_name):
    with open(file_name, "r", encoding="utf-8") as f:
        tree = ast.parse(f.read(), filename=file_name)

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and node.name == function_name:
            return "# " + file_name + "\n" + ast.get_source_segment(open(file_name, encoding="utf-8").read(), node)

    raise ValueError(f"Function '{function_name}' not found in '{file_name}'")

if __name__ == "__main__":
    main()